<!doctype html>
<!--[if lt IE 7]>  <html class="ie ie8 ie7 ie6" lang="en"> <![endif]-->
<!--[if IE 7]>     <html class="ie ie8 ie7" lang="en"> <![endif]-->
<!--[if IE 8]>     <html class="ie ie8" lang="en"> <![endif]-->
<!--[if IE]>       <html class="ie" lang="en"> <![endif]-->
<!--[if !IE]><!--> <html lang="en"> <!--<![endif]-->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    


<title>in / ject // Deep iFraming</title>
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="../../css/master.css" />
</head>

<body>

    <div id="master" class="whiteblack go read">
        <div id="left">

            <img src="../../img/syringe_b-w.png" id="syringe"/>
            <div id="name">
                <h1>IN.JECT</h1>
            </div>
            <div id="title"></div>
        </div>
        <div id="right">
            <div class="content ready"><h5>24.08.12</h5><h1>Deep iFraming</h1><p>the thing about frames</p>

<p>iframes are a painfully outdated element of HTML, in my humble opinion. there are far more interesting ways to bring in outside content by way of ajax, and I've come to understand that said ways are far safer than the alternative. however, there are times when you may still need to use the erstwhile element: say, when something you have to import onto a page exists elsewhere on the internet. ajax can only bring in stuff from your domain, so an iframe can be particularly useful when you have a form from another site to drop on to your site.</p>

<p>if that's all you've got to do, you're done. iframes can be imported dynamically through ajax, which is a somewhat roundabout way of bringing in stuff residing elsewhere; but effective, nonetheless. however, I've come across the problem that the form I'm dropping onto my page may be perused by legacy users, who have had vested interest in the form beforehand. they have presumably received an email that contains a link to the site, generated by the outlying company, that ought to bring them to a user-specific page. if you're following along at home, this means that they'll come to my site with the expectation of viewing content tailored to them specifically; that exists elsewhere, and that I have no control over.</p>

<p>er. a somewhat tall order, but nothing we can't deal with.</p>

<p>having already conquered the parsing of the hashtag with HTML5's handy dandy window.location.hash element, I should be able to get the goods with something along those lines. the goods here are:</p>

<pre><code>    &amp;pin=123&amp;step=2
</code></pre>

<p>123 and 2 are placeholder data, but the final string will look something like that. as we must account for the fact that not all users will be coming to the site with such a string at the end of their URL, we must have an if statement, in the if statement. it looks something like this:</p>

<pre><code>    if (window.location.hash.indexOf('#foo') == 0){
        if (window.location.hash.indexOf('&amp;pin=') &gt; 0 ){

        }
    }
</code></pre>

<p>again, if you've been reading along at home, you know that my usual method for pulling out the hash and doing something in ajax with it goes something like this:</p>

<pre><code>    if (window.location.hash == "#foo"){
        //do actions to get back to pagetitle
    }
</code></pre>

<p>unfortunately, as the hash isn't equal to just #foo, we need something to pick out our hash. we know that #foo will always be passed, so as long as it's a part of the hash itself, indexOf (which returns a somewhat backwards boolean of 1 and 0) works wonders. having addressed site comers without a fancy identifying string, indexOf() also takes care of those with a string, as setting the conditional to greater than will pass as true if the passed string exists anywhere in the results through which it combs. if we wanted to get super particular about this, indexOf can also pass a second variable as an index at which to begin looking. but we don't need that kind of resolution here, as we know the incoming string, so we're good.</p>

<p>however, we now have the issue of passing the string after the hash to the iframe. I'm sure there are far more elegant solutions to this, but this has worked marvelously for me. with a quick bit of regular expressions pulled from a fellow named 'Gumbo' at stackoverflow.com, modified to my purposes for pulling out what comes after the ampersand, you can store whatever bits are encoded into the URL with this:</p>

<pre><code>    var match = window.location.href.match(/^[^#]+#([^&amp;]*)\??(.*)/);
</code></pre>

<p>from there, now that this is stored locally as a variable, we can slide it into an iframe with the .html() command in jquery:</p>

<pre><code>    $(".foobar").html('&lt;iframe src="http://foobar.com/#foo'+match[2]+'"&gt;&lt;/iframe&gt;');
</code></pre>

<p>I don't know a damn thing thing about regular expressions (beyond that it looks like gibberish) but I suspect that the results are appended into an array, the second entry of which contains what we need. the iframe is inserted into the appropriate container, with the appropriate user-specific content concatenated into the page displayed in said iframe. the whole thing is as simple as this:</p>

<pre><code>    if (window.location.hash.indexOf('#foo') == 0){
        if (window.location.hash.indexOf('&amp;pin=') &gt; 0 ){
            var match = window.location.href.match(/^[^#]+#([^&amp;]*)\??(.*)/);
            $(".foobar").html('&lt;iframe src="http://foobar.com/?foobar'+match[2]+'"&gt;&lt;/iframe&gt;');
        }
    }
</code></pre>

<p>having received a URL of:</p>

<pre><code>    http://barbiz.com/#foo&amp;pin=123&amp;step=2
</code></pre>

<p>simple, elegant, and fully functional!</p>

            </div>
        </div>
    </div>
    <script>
    	var thehash = window.location.pathname.split('/')
    	thehash = thehash[thehash.length-1].split('.')[0]
    	console.log(thehash)
    	window.location = window.location.origin + '/#!' + thehash;
    </script>

</body>